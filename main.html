<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sprinkle Scream Cats</title>
  <style>
    :root{
      --thresholdDb: 10; /* CHANGED from 20 -> 10 */
      --maxDb: 55;       /* how fast it ramps to "all cats screaming" */
    }

    html, body { height: 100%; }

    body{
      margin:0;
      overflow:hidden;
      font-family: system-ui, -apple-system, Segoe UI, Arial, sans-serif;

      /* Rainbow background */
      background: linear-gradient(90deg,
        #ff4d4d, #ff9a4d, #ffe74d, #7dff4d, #4dffd8, #4d7dff, #b14dff, #ff4dd8
      );
    }

    /* Top controls */
    .topbar{
      position: fixed;
      top: 12px;
      left: 12px;
      right: 12px;
      z-index: 10;

      display:flex;
      gap: 10px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;

      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(255,255,255,0.85);
      backdrop-filter: blur(6px);
      box-shadow: 0 10px 28px rgba(0,0,0,0.18);
    }

    .controls{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }

    button{
      border: none;
      border-radius: 12px;
      padding: 10px 14px;
      font-weight: 800;
      cursor:pointer;
      box-shadow: 0 6px 16px rgba(0,0,0,0.15);
    }
    #startBtn{ background: #ffffff; }
    #stopBtn{ background: #111; color:#fff; }

    .readout{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      font-weight:800;
    }
    .pill{
      background: rgba(255,255,255,0.75);
      padding: 6px 10px;
      border-radius: 999px;
    }

    /* Sprinkle field (NO translucent white panel) */
    #field{
      position: relative;
      width: 100%;
      height: 100%;
    }

    .cat{
      position:absolute;
      user-select:none;
      pointer-events:none;
      filter: drop-shadow(0 10px 16px rgba(0,0,0,0.20));
      will-change: transform, top, left;
    }
    .cat img{
      display:block;
      width: 140px;  /* change for bigger/smaller cats */
      height: auto;
    }
  </style>
</head>

<body>
  <div class="topbar">
    <div class="controls">
      <button id="startBtn">Start mic</button>
      <button id="stopBtn" disabled>Stop</button>
    </div>

    <div class="readout">
      <span class="pill">dB: <b id="db">--</b></span>
      <span class="pill">Screaming: <b id="count">0</b>/<b id="total">0</b></span>
      <span class="pill" id="status">Mic: off</span>
    </div>
  </div>

  <div id="field"></div>

  <script>
    // --- Your files (from the ZIP) are in the SAME folder as index.html ---
    // Files: "normal 1.png"..."normal 4.png" and "scream 1.png"..."scream 4.png"
    const CAT_NUMBERS = [1,2,3,4];
    const DUPLICATES_PER_CAT = 2; // each cat twice -> 8 cats total

    // Audio "dB" here is relative to a reference level (not a certified SPL meter).
    const REF_RMS = 0.01;

    const THRESHOLD_DB = 10; // CHANGED as requested
    const MAX_DB = 55;

    const field = document.getElementById("field");
    const dbEl = document.getElementById("db");
    const countEl = document.getElementById("count");
    const totalEl = document.getElementById("total");
    const statusEl = document.getElementById("status");

    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");

    // Build slots: [1,1,2,2,3,3,4,4] but each is its own "sprinkle"
    const slots = [];
    for (const n of CAT_NUMBERS){
      for (let k = 0; k < DUPLICATES_PER_CAT; k++){
        slots.push({ n, k });
      }
    }
    totalEl.textContent = slots.length;

    function filePath(kind, n){
      // kind: "normal" or "scream"
      // Encode spaces -> %20 so the browser loads correctly.
      return encodeURIComponent(`${kind} ${n}.png`);
    }

    // Create cat elements
    const cats = [];
    for (const s of slots){
      const wrap = document.createElement("div");
      wrap.className = "cat";

      // Slight random rotation/scale for “sprinkles”
      const rot = (Math.random()*24 - 12).toFixed(2); // -12..12 deg
      const scale = (0.85 + Math.random()*0.5).toFixed(2); // 0.85..1.35
      wrap.style.transform = `rotate(${rot}deg) scale(${scale})`;

      const img = document.createElement("img");
      img.alt = `cat ${s.n}`;
      img.src = filePath("normal", s.n);

      // Helpful debugging: if a file name/path is wrong, this will tell you in console
      img.onerror = () => {
        console.warn("Image failed to load:", img.src,
          "Make sure PNGs are in the same folder as index.html and names match exactly.");
      };

      wrap.appendChild(img);
      field.appendChild(wrap);

      cats.push({ wrap, img, n: s.n });
    }

    function sprinkleLayout(){
      const W = window.innerWidth;
      const H = window.innerHeight;

      // Leave space for the topbar so cats don’t hide behind it
      const topPadding = 90;

      // “Good enough” non-overlap: random positions with a minimum distance
      const minDist = 120; // increase = more spaced out
      const placed = [];

      for (const c of cats){
        let x, y;
        let tries = 0;
        while (true){
          tries++;
          x = Math.random() * (W - 180) + 20;
          y = Math.random() * (H - topPadding - 180) + topPadding + 20;

          let ok = true;
          for (const p of placed){
            const dx = x - p.x;
            const dy = y - p.y;
            if ((dx*dx + dy*dy) < (minDist*minDist)){
              ok = false;
              break;
            }
          }
          if (ok || tries > 80) break; // don’t get stuck forever
        }

        c.wrap.style.left = `${x}px`;
        c.wrap.style.top  = `${y}px`;
        placed.push({x,y});
      }
    }

    sprinkleLayout();
    window.addEventListener("resize", sprinkleLayout);

    function rmsToDb(rms){
      const safe = Math.max(rms, 1e-8);
      return 20 * Math.log10(safe / REF_RMS);
    }

    function setScreamingCount(num){
      for (let i = 0; i < cats.length; i++){
        const kind = (i < num) ? "scream" : "normal";
        cats[i].img.src = filePath(kind, cats[i].n);
      }
      countEl.textContent = num;
    }

    // Start with all calm
    setScreamingCount(0);

    // --- Mic ---
    let audioCtx, analyser, stream, rafId;

    function rmsFromFloatTimeDomain(data){
      let sum = 0;
      for (let i = 0; i < data.length; i++){
        const x = data[i];
        sum += x*x;
      }
      return Math.sqrt(sum / data.length);
    }

    function loop(){
      if (!analyser || !audioCtx) return;

      const buffer = new Float32Array(analyser.fftSize);
      analyser.getFloatTimeDomainData(buffer);

      // Smooth a bit by mixing current with last
      const rms = rmsFromFloatTimeDomain(buffer);
      const db = rmsToDb(rms);

      dbEl.textContent = db.toFixed(1);

      let screaming = 0;
      if (db > THRESHOLD_DB){
        const t = Math.min(1, Math.max(0, (db - THRESHOLD_DB) / (MAX_DB - THRESHOLD_DB)));
        screaming = Math.max(1, Math.floor(t * cats.length));
      }
      setScreamingCount(screaming);

      rafId = requestAnimationFrame(loop);
    }

    async function startMic(){
      try{
        stream = await navigator.mediaDevices.getUserMedia({
          audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
        });

        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioCtx.createMediaStreamSource(stream);

        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;
        analyser.smoothingTimeConstant = 0.6;

        source.connect(analyser);

        startBtn.disabled = true;
        stopBtn.disabled = false;
        statusEl.textContent = "Mic: on";

        loop();
      } catch(e){
        statusEl.textContent = "Mic: blocked";
        alert("Mic permission denied or unavailable.");
        console.error(e);
      }
    }

    function stopMic(){
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;

      if (stream){
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      if (audioCtx){
        audioCtx.close();
        audioCtx = null;
      }
      analyser = null;

      startBtn.disabled = false;
      stopBtn.disabled = true;

      dbEl.textContent = "--";
      statusEl.textContent = "Mic: off";
      setScreamingCount(0);
    }

    startBtn.addEventListener("click", startMic);
    stopBtn.addEventListener("click", stopMic);
  </script>
</body>
</html>
